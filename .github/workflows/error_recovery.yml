name: Error Recovery Handler

on:
  # Manually trigger error recovery for any failed workflow
  workflow_dispatch:
    inputs:
      workflow_id:
        description: 'Workflow Run ID to recover (required)'
        required: true
      repo_path:
        description: 'Target repository path'
        required: true
        default: '.'
      autonomous_mode:
        description: 'Apply fixes automatically'
        required: false
        type: boolean
        default: false
      error_type:
        description: 'Type of error (optional, will auto-detect if not specified)'
        required: false
        type: choice
        options:
          - auto_detect
          - api_error
          - terraform_error
          - permission_error
          - resource_error
          - network_error
          - validation_error
          - system_error
          - unknown_error
        default: 'auto_detect'
      error_message:
        description: 'Error message (optional, will auto-detect if not specified)'
        required: false
      artifact_name:
        description: 'Name of error artifact (optional)'
        required: false
  
  # Scheduled check for any failed workflows (runs every hour)
  schedule:
    - cron: '5 * * * *'  # Run 5 minutes past every hour
  
  # Automatically trigger when other workflows fail
  workflow_run:
    workflows: ['*']  # Listen to all workflows
    types:
      - completed

jobs:
  error-recovery:
    runs-on: ubuntu-latest
    # Only run when the triggering workflow has failed or when manually triggered or on schedule
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'failure') || 
      github.event_name == 'schedule'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install google-generativeai
      
      - name: Set up artifact directory
        id: setup
        run: |
          mkdir -p recovery_artifacts
          echo "ARTIFACTS_DIR=$(pwd)/recovery_artifacts" >> $GITHUB_ENV
          echo "RUN_TIMESTAMP=$(date +%Y%m%d_%H%M%S)" >> $GITHUB_ENV
      
      - name: Find failed workflow runs
        id: find_failed
        if: ${{ github.event_name == 'schedule' }}
        uses: actions/github-script@v6
        with:
          script: |
            // Get the latest workflow runs
            const workflowRuns = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              status: 'failure',
              per_page: 5  // Get the most recent 5 failed runs
            });
            
            if (workflowRuns.data.total_count === 0) {
              console.log('No failed workflow runs found');
              return {
                workflowId: null,
                runId: null,
                workflowName: null
              };
            }
            
            // Filter out our own error recovery workflow to avoid circular processing
            const relevantRuns = workflowRuns.data.workflow_runs.filter(
              run => !run.name.toLowerCase().includes('error recovery')
            );
            
            if (relevantRuns.length === 0) {
              console.log('No relevant failed workflow runs found');
              return {
                workflowId: null,
                runId: null,
                workflowName: null
              };
            }
            
            const latestRun = relevantRuns[0];
            console.log(`Found failed workflow: ${latestRun.name}, run ID: ${latestRun.id}`);
            
            return {
              workflowId: latestRun.workflow_id,
              runId: latestRun.id,
              workflowName: latestRun.name
            };
      
      - name: Determine workflow run to analyze
        id: determine_workflow
        run: |
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            # Direct workflow_run trigger
            echo "run_id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
            echo "workflow_name=${{ github.event.workflow_run.name }}" >> $GITHUB_OUTPUT
            echo "Analysis source: Directly triggered by workflow_run event"
          elif [ "${{ github.event_name }}" == "schedule" ]; then
            # Scheduled check for failed workflows
            if [ -n "${{ steps.find_failed.outputs.result }}" ]; then
              # Parse the JSON safely with a fallback
              RUN_ID="${{ fromJSON(steps.find_failed.outputs.result || '{"runId":null,"workflowName":"Unknown"}').runId }}"
              WORKFLOW_NAME="${{ fromJSON(steps.find_failed.outputs.result || '{"runId":null,"workflowName":"Unknown"}').workflowName }}"
              
              if [ "$RUN_ID" != "null" ] && [ -n "$RUN_ID" ]; then
                echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
                echo "workflow_name=$WORKFLOW_NAME" >> $GITHUB_OUTPUT
                echo "Analysis source: Scheduled check found failed workflow: $WORKFLOW_NAME"
              else
                echo "No failed workflows found to analyze"
                exit 0
              fi
            else
              echo "No failed workflows found to analyze"
              exit 0
            fi
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Direct workflow ID provided - this is the simplified mode
            echo "run_id=${{ github.event.inputs.workflow_id }}" >> $GITHUB_OUTPUT
            echo "workflow_name=Specified Workflow ID: ${{ github.event.inputs.workflow_id }}" >> $GITHUB_OUTPUT
            echo "Analysis source: Manually specified workflow ID: ${{ github.event.inputs.workflow_id }}"
          else
            # Fallback - just use the inputs directly
            echo "run_id=manual" >> $GITHUB_OUTPUT
            echo "workflow_name=Manual Trigger" >> $GITHUB_OUTPUT
            echo "Analysis source: Manual trigger with no specific workflow"
          fi
      
      - name: Download workflow artifacts
        if: ${{ steps.determine_workflow.outputs.run_id != 'manual' && steps.determine_workflow.outputs.run_id != '' }}
        uses: actions/github-script@v6
        with:
          script: |
            const runId = '${{ steps.determine_workflow.outputs.run_id }}';
            console.log(`Downloading artifacts for run ID: ${runId}`);
            
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });
            
            // Download all artifacts, prioritizing ones that might contain error info
            const allArtifacts = artifacts.data.artifacts;
            console.log(`Found ${allArtifacts.length} artifacts`);
            
            // Sort artifacts to prioritize likely error artifacts first
            const sortedArtifacts = allArtifacts.sort((a, b) => {
              const aName = a.name.toLowerCase();
              const bName = b.name.toLowerCase();
              
              const aScore = (aName.includes('error') ? 3 : 0) + 
                            (aName.includes('result') ? 2 : 0) + 
                            (aName.includes('inframate') ? 1 : 0);
              
              const bScore = (bName.includes('error') ? 3 : 0) + 
                            (bName.includes('result') ? 2 : 0) + 
                            (bName.includes('inframate') ? 1 : 0);
              
              return bScore - aScore;  // Higher score first
            });
            
            // Download up to 3 highest-priority artifacts
            const artifactsToDownload = sortedArtifacts.slice(0, 3);
            
            if (artifactsToDownload.length === 0) {
              console.log('No artifacts found');
            } else {
              for (const artifact of artifactsToDownload) {
                console.log(`Downloading artifact: ${artifact.name}`);
                
                try {
                  const download = await github.rest.actions.downloadArtifact({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    artifact_id: artifact.id,
                    archive_format: 'zip'
                  });
                  
                  const fs = require('fs');
                  fs.writeFileSync(`${process.env.ARTIFACTS_DIR}/${artifact.name}.zip`, Buffer.from(download.data));
                  
                  // Extract the artifact
                  const { execSync } = require('child_process');
                  execSync(`unzip -o ${process.env.ARTIFACTS_DIR}/${artifact.name}.zip -d ${process.env.ARTIFACTS_DIR}/${artifact.name}`);
                  
                  console.log(`Extracted artifact: ${artifact.name}`);
                } catch (error) {
                  console.log(`Error downloading artifact ${artifact.name}: ${error.message}`);
                }
              }
            }
      
      - name: Download specific artifact (if workflow_dispatch with artifact_name)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.artifact_name != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact_name }}
          path: ${{ env.ARTIFACTS_DIR }}/manual_artifact
      
      - name: Extract error information
        id: extract_error
        run: |
          # Default values or provided inputs
          REPO_PATH="${{ github.event.inputs.repo_path || '.' }}"
          AUTONOMOUS="${{ github.event.inputs.autonomous_mode == 'true' && '--autonomous' || '' }}"
          WORKFLOW_NAME="${{ steps.determine_workflow.outputs.workflow_name || 'Unknown Workflow' }}"
          
          # Default or user-provided error type
          if [ "${{ github.event.inputs.error_type }}" == "auto_detect" ] || [ -z "${{ github.event.inputs.error_type }}" ]; then
            ERROR_TYPE="unknown_error"  # Default, will try to detect
            AUTO_DETECT=true
          else
            ERROR_TYPE="${{ github.event.inputs.error_type }}"
            AUTO_DETECT=false
          fi
          
          # Default or user-provided error message
          if [ -z "${{ github.event.inputs.error_message }}" ]; then
            ERROR_MESSAGE="Unknown error - will attempt to detect from workflow artifacts"
            AUTO_DETECT_MESSAGE=true
          else
            ERROR_MESSAGE="${{ github.event.inputs.error_message }}"
            AUTO_DETECT_MESSAGE=false
          fi
          
          # For workflow runs with ID, try to extract info from logs and artifacts
          if [ "${{ steps.determine_workflow.outputs.run_id }}" != "manual" ] && [ "$AUTO_DETECT" == "true" ]; then
            echo "Auto-detecting error information from workflow ID: ${{ steps.determine_workflow.outputs.run_id }}"
            
            # Get workflow run info (if we have GH CLI installed)
            if command -v gh &> /dev/null; then
              echo "Using GitHub CLI to get workflow run details..."
              mkdir -p ${ARTIFACTS_DIR}/logs
              
              # Get run logs
              gh run view ${{ steps.determine_workflow.outputs.run_id }} --log > ${ARTIFACTS_DIR}/logs/workflow.log 2>/dev/null || echo "Could not get workflow logs"
              
              # Extract workflow name and status
              WORKFLOW_INFO=$(gh run view ${{ steps.determine_workflow.outputs.run_id }} --json name,status 2>/dev/null || echo '{"name":"Unknown","status":"unknown"}')
              
              # Get a better workflow name if available
              DETECTED_NAME=$(echo $WORKFLOW_INFO | jq -r '.name')
              if [ "$DETECTED_NAME" != "null" ] && [ "$DETECTED_NAME" != "Unknown" ]; then
                WORKFLOW_NAME="$DETECTED_NAME"
                echo "Detected workflow name: $WORKFLOW_NAME"
              fi
            fi
            
            # Look for error files in all extracted directories
            ERROR_FILES=$(find $ARTIFACTS_DIR -type f -name "*.json" | grep -E "results|errors|output")
            
            if [ -n "$ERROR_FILES" ]; then
              # Use the first error file found
              ERROR_FILE=$(echo "$ERROR_FILES" | head -n 1)
              echo "Found error file: $ERROR_FILE"
              
              # Extract error type and message
              if [ -f "$ERROR_FILE" ]; then
                # Try multiple JSON paths where error info might be stored
                EXTRACTED_TYPE=$(jq -r '.error.type // .error_type // .type // "unknown_error"' "$ERROR_FILE")
                EXTRACTED_MSG=$(jq -r '.error.message // .error_message // .message // "Unknown error"' "$ERROR_FILE")
                
                if [ "$EXTRACTED_TYPE" != "null" ] && [ "$EXTRACTED_TYPE" != "" ]; then
                  ERROR_TYPE="$EXTRACTED_TYPE"
                  echo "Detected error type: $ERROR_TYPE"
                fi
                
                if [ "$EXTRACTED_MSG" != "null" ] && [ "$EXTRACTED_MSG" != "" ] && [ "$AUTO_DETECT_MESSAGE" == "true" ]; then
                  ERROR_MESSAGE="$EXTRACTED_MSG"
                  echo "Detected error message: $ERROR_MESSAGE"
                fi
              fi
            else
              echo "No error files found in artifacts, trying to detect from logs"
              
              # Search logs for common error patterns if available
              if [ -f "${ARTIFACTS_DIR}/logs/workflow.log" ]; then
                echo "Analyzing workflow logs for error patterns..."
                
                # Check for common error patterns
                if grep -q "terraform.*error" ${ARTIFACTS_DIR}/logs/workflow.log; then
                  ERROR_TYPE="terraform_error"
                  if [ "$AUTO_DETECT_MESSAGE" == "true" ]; then
                    ERROR_MESSAGE=$(grep -m 1 "terraform.*error" ${ARTIFACTS_DIR}/logs/workflow.log | head -n 1)
                  fi
                  echo "Detected Terraform error"
                elif grep -q "permission denied" ${ARTIFACTS_DIR}/logs/workflow.log; then
                  ERROR_TYPE="permission_error"
                  if [ "$AUTO_DETECT_MESSAGE" == "true" ]; then
                    ERROR_MESSAGE=$(grep -m 1 "permission denied" ${ARTIFACTS_DIR}/logs/workflow.log | head -n 1)
                  fi
                  echo "Detected permission error"
                elif grep -q "network.*error" ${ARTIFACTS_DIR}/logs/workflow.log; then
                  ERROR_TYPE="network_error"
                  if [ "$AUTO_DETECT_MESSAGE" == "true" ]; then
                    ERROR_MESSAGE=$(grep -m 1 "network.*error" ${ARTIFACTS_DIR}/logs/workflow.log | head -n 1)
                  fi
                  echo "Detected network error"
                elif grep -q "rate limit" ${ARTIFACTS_DIR}/logs/workflow.log; then
                  ERROR_TYPE="api_error"
                  if [ "$AUTO_DETECT_MESSAGE" == "true" ]; then
                    ERROR_MESSAGE=$(grep -m 1 "rate limit" ${ARTIFACTS_DIR}/logs/workflow.log | head -n 1)
                  fi
                  echo "Detected API rate limit error"
                fi
              fi
            fi
          fi
          
          echo "error_type=$ERROR_TYPE" >> $GITHUB_OUTPUT
          echo "error_message=$ERROR_MESSAGE" >> $GITHUB_OUTPUT
          echo "repo_path=$REPO_PATH" >> $GITHUB_OUTPUT
          echo "autonomous=$AUTONOMOUS" >> $GITHUB_OUTPUT
          echo "workflow_name=$WORKFLOW_NAME" >> $GITHUB_OUTPUT
          
          echo "Final error details:"
          echo "Error type: $ERROR_TYPE"
          echo "Error message: $ERROR_MESSAGE"
          echo "Repository path: $REPO_PATH"
          echo "Workflow: $WORKFLOW_NAME"
      
      - name: Run error recovery handler
        id: recovery
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create error context file
          cat > ${ARTIFACTS_DIR}/error_context.json << EOF
          {
            "error_type": "${{ steps.extract_error.outputs.error_type }}",
            "error_message": "${{ steps.extract_error.outputs.error_message }}",
            "timestamp": $(date +%s),
            "workflow": "${{ steps.extract_error.outputs.workflow_name }}",
            "workflow_id": "${{ steps.determine_workflow.outputs.run_id || github.run_id }}",
            "repo_path": "${{ steps.extract_error.outputs.repo_path }}"
          }
          EOF
          
          # Run the error flow directly
          echo "Running error recovery flow..."
          ERROR_RECOVERY_CMD="python scripts/debug_error_flow.py --action inject --error-type ${{ steps.extract_error.outputs.error_type }} --repo-path ${{ steps.extract_error.outputs.repo_path }}"
          
          $ERROR_RECOVERY_CMD 2>&1 | tee ${ARTIFACTS_DIR}/recovery_log.txt
          
          # Parse recovery log for results (this is a simple check)
          if grep -q "Error handler result: success=true" ${ARTIFACTS_DIR}/recovery_log.txt; then
            echo "recovery_success=true" >> $GITHUB_OUTPUT
            echo "::notice::Error recovery was successful"
          else
            echo "recovery_success=false" >> $GITHUB_OUTPUT
            echo "::warning::Error recovery was not successful"
          fi
          
          # Also run the full error workflow in autonomous mode if requested
          if [ "${{ steps.extract_error.outputs.autonomous }}" == "--autonomous" ]; then
            echo "Running full error recovery workflow in autonomous mode..."
            WORKFLOW_CMD="./scripts/run_agentic_workflow.sh --repo-path ${{ steps.extract_error.outputs.repo_path }} --action auto --autonomous --output ${ARTIFACTS_DIR}/recovery_results.json --error-mode verbose"
            
            $WORKFLOW_CMD 2>&1 | tee -a ${ARTIFACTS_DIR}/recovery_log.txt
          fi
      
      - name: Generate recovery report
        run: |
          echo "## Error Recovery Report" > ${ARTIFACTS_DIR}/recovery_report.md
          echo "" >> ${ARTIFACTS_DIR}/recovery_report.md
          echo "### Error Details" >> ${ARTIFACTS_DIR}/recovery_report.md
          echo "- **Type:** ${{ steps.extract_error.outputs.error_type }}" >> ${ARTIFACTS_DIR}/recovery_report.md
          echo "- **Message:** ${{ steps.extract_error.outputs.error_message }}" >> ${ARTIFACTS_DIR}/recovery_report.md
          echo "- **Workflow:** ${{ steps.extract_error.outputs.workflow_name }}" >> ${ARTIFACTS_DIR}/recovery_report.md
          echo "- **Workflow Run ID:** ${{ steps.determine_workflow.outputs.run_id || 'manual' }}" >> ${ARTIFACTS_DIR}/recovery_report.md
          echo "- **Timestamp:** $(date)" >> ${ARTIFACTS_DIR}/recovery_report.md
          echo "" >> ${ARTIFACTS_DIR}/recovery_report.md
          
          echo "### Recovery Result" >> ${ARTIFACTS_DIR}/recovery_report.md
          if [ "${{ steps.recovery.outputs.recovery_success }}" == "true" ]; then
            echo "✅ **Recovery successful**" >> ${ARTIFACTS_DIR}/recovery_report.md
          else
            echo "❌ **Recovery failed**" >> ${ARTIFACTS_DIR}/recovery_report.md
          fi
          echo "" >> ${ARTIFACTS_DIR}/recovery_report.md
          
          echo "### Recovery Log" >> ${ARTIFACTS_DIR}/recovery_report.md
          echo '```' >> ${ARTIFACTS_DIR}/recovery_report.md
          tail -n 50 ${ARTIFACTS_DIR}/recovery_log.txt >> ${ARTIFACTS_DIR}/recovery_report.md
          echo '```' >> ${ARTIFACTS_DIR}/recovery_report.md
          
          # Extract AI solution if available
          if [ -f "${ARTIFACTS_DIR}/recovery_results.json" ]; then
            echo "" >> ${ARTIFACTS_DIR}/recovery_report.md
            echo "### AI Solution" >> ${ARTIFACTS_DIR}/recovery_report.md
            
            # Extract root cause
            ROOT_CAUSE=$(jq -r '.error.ai_solution.root_cause // "Not available"' "${ARTIFACTS_DIR}/recovery_results.json")
            echo "#### Root Cause" >> ${ARTIFACTS_DIR}/recovery_report.md
            echo "${ROOT_CAUSE}" >> ${ARTIFACTS_DIR}/recovery_report.md
            echo "" >> ${ARTIFACTS_DIR}/recovery_report.md
            
            # Extract solution
            SOLUTION=$(jq -r '.error.ai_solution.solution // "No solution available"' "${ARTIFACTS_DIR}/recovery_results.json")
            echo "#### Solution" >> ${ARTIFACTS_DIR}/recovery_report.md
            echo "${SOLUTION}" >> ${ARTIFACTS_DIR}/recovery_report.md
          fi
      
      - name: Create issue with recovery report
        if: ${{ steps.recovery.outputs.recovery_success != 'true' }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('${{ env.ARTIFACTS_DIR }}/recovery_report.md', 'utf8');
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Error Recovery Failed: ${{ steps.extract_error.outputs.error_type }} in ${{ steps.extract_error.outputs.workflow_name }}`,
              body: report,
              labels: ['error', 'recovery-failed', 'automated']
            });
            
            console.log(`Created issue #${issue.data.number}`);
      
      - name: Retry failed workflow if recovery was successful
        if: ${{ steps.recovery.outputs.recovery_success == 'true' && steps.determine_workflow.outputs.run_id != 'manual' && steps.determine_workflow.outputs.run_id != '' }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('${{ env.ARTIFACTS_DIR }}/recovery_report.md', 'utf8');
            
            // Get the workflow that failed
            const workflowRun = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ${{ steps.determine_workflow.outputs.run_id }}
            });
            
            // Create comment on the workflow run
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflowRun.data.workflow_id,
              ref: workflowRun.data.head_branch || 'main',
              inputs: workflowRun.data.inputs || {}
            });
            
            console.log(`Triggered re-run of workflow: ${workflowRun.data.workflow_id}`);
            
            // Create a comment in the PR if this was a PR-triggered workflow
            if (workflowRun.data.pull_requests && workflowRun.data.pull_requests.length > 0) {
              const prNumber = workflowRun.data.pull_requests[0].number;
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## ✅ Automated Error Recovery Successful\n\nError recovery for workflow "${workflowRun.data.name}" was successful. The workflow has been re-triggered.\n\n${report}`
              });
              
              console.log(`Created comment on PR #${prNumber}`);
            }
      
      - name: Upload recovery artifacts
        uses: actions/upload-artifact@v4
        with:
          name: error-recovery-${{ env.RUN_TIMESTAMP }}
          path: ${{ env.ARTIFACTS_DIR }}
      
      - name: Report workflow completion
        if: always()
        run: |
          if [ "${{ steps.recovery.outputs.recovery_success }}" == "true" ]; then
            echo "::notice::Error recovery completed successfully"
            echo "Check the artifacts for recovery details"
          else
            echo "::warning::Error recovery failed"
            echo "An issue has been created with recovery details"
          fi 