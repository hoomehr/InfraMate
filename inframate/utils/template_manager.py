"""
Template manager for loading and modifying Terraform templates
"""
import os
import re
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

class TemplateManager:
    def __init__(self):
        self.template_dir = Path(__file__).parent.parent.parent / "templates" / "aws" / "terraform"
        self.templates = {}
        self._load_templates()

    def _load_templates(self):
        """Load all Terraform templates from the templates directory"""
        for template_file in self.template_dir.glob("*.tf"):
            with open(template_file, "r") as f:
                self.templates[template_file.stem] = f.read()

    def get_template(self, template_name: str) -> Optional[str]:
        """Get a specific template by name"""
        return self.templates.get(template_name)

    def extract_outputs(self, template: str) -> Tuple[Set[str], str]:
        """
        Extract output names from a Terraform template
        
        Args:
            template: Terraform template content
            
        Returns:
            Tuple of (set of output names, template with outputs extracted but NOT removed)
        """
        output_names = set()
        
        # Match all output blocks to extract their names
        output_pattern = re.compile(r'output\s+"([^"]+)"\s+{', re.DOTALL)
        matches = output_pattern.finditer(template)
        
        for match in matches:
            output_name = match.group(1)
            output_names.add(output_name)
        
        return output_names, template

    def fix_template_issues(self, template: str) -> str:
        """Fix common issues in Terraform templates"""
        # Fix network_interface vs network_interfaces block issue in launch_template
        template = re.sub(
            r'(resource\s+"aws_launch_template"\s+"[^"]+"\s+{\s+[^}]*?)network_interface\s+{',
            r'\1network_interfaces {',
            template,
            flags=re.DOTALL
        )
        
        # Ensure all referenced resources in outputs have try() functions
        template = re.sub(
            r'(output\s+"[^"]+"\s+{\s+[^}]*?value\s+=\s+)([a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+)([^}]*?})',
            r'\1try(\2, "N/A")\3',
            template,
            flags=re.DOTALL
        )
        
        # Ensure we don't have duplicate resource definitions
        seen_resources = {}
        clean_lines = []
        current_resource = None
        skip_block = False
        bracket_count = 0
        
        for line in template.split("\n"):
            # Check for resource definition start
            resource_match = re.match(r'resource\s+"([^"]+)"\s+"([^"]+)"\s+{', line)
            if resource_match and not current_resource:
                resource_type, resource_name = resource_match.groups()
                resource_key = f"{resource_type}.{resource_name}"
                
                if resource_key in seen_resources:
                    # Skip this duplicate resource
                    skip_block = True
                    bracket_count = 1
                else:
                    seen_resources[resource_key] = True
                    current_resource = resource_key
                    skip_block = False
                    bracket_count = 1
            
            # Count brackets to track when we exit the resource block
            if skip_block:
                if "{" in line:
                    bracket_count += line.count("{")
                if "}" in line:
                    bracket_count -= line.count("}")
                    
                if bracket_count == 0:
                    skip_block = False
                    current_resource = None
                    
                # Skip the line since we're in a duplicate resource
                continue
                
            # Normal line processing
            if "{" in line and current_resource:
                bracket_count += line.count("{")
            if "}" in line and current_resource:
                bracket_count -= line.count("}")
                if bracket_count == 0:
                    current_resource = None
            
            clean_lines.append(line)
        
        return "\n".join(clean_lines)

    def combine_templates(self, template_names: List[str]) -> str:
        """Combine multiple templates into a single Terraform configuration"""
        combined = """# Terraform configuration generated by Inframate
provider "aws" {
  region = var.region
}

"""
        for name in template_names:
            template = self.get_template(name)
            if template:
                combined += f"\n# {name} configuration\n{template}\n"

        # Fix common template issues
        combined = self.fix_template_issues(combined)
        
        return combined

    def get_template_for_services(self, services: List[str]) -> str:
        """Get appropriate templates based on the list of services"""
        template_names = []
        
        # Map services to template names
        service_to_template = {
            # Compute Services
            "Lambda": "nodejs_lambda",
            "API Gateway": "nodejs_lambda",  # Included in nodejs_lambda template
            "EC2": "ec2",
            "ECS": "ecs",
            "EKS": "eks",
            "Elastic Beanstalk": "elastic_beanstalk",
            
            # Storage Services
            "S3": "webapp",
            "CloudFront": "webapp",  # Included in webapp template
            "EFS": "efs",
            
            # Database Services
            "RDS": "database",
            "DocumentDB": "database",
            "ElastiCache": "database",
            "DynamoDB": "dynamodb",
            
            # Networking Services
            "VPC": "vpc",
            "Route53": "route53",
            "CloudFront": "cloudfront",
            "API Gateway": "api_gateway",
            
            # Load Balancing
            "ALB": "alb",
            "NLB": "nlb",
            
            # Security Services
            "WAF": "waf",
            "Shield": "shield",
            "GuardDuty": "guardduty",
            
            # Monitoring Services
            "CloudWatch": "cloudwatch",
            "X-Ray": "xray",
            
            # CI/CD Services
            "CodeBuild": "codebuild",
            "CodePipeline": "codepipeline",
            "CodeDeploy": "codedeploy"
        }

        # Add templates based on services
        for service in services:
            template_name = service_to_template.get(service)
            if template_name and template_name not in template_names:
                template_names.append(template_name)

        # Always include these templates
        required_templates = ["variables", "vpc"]
        for template in required_templates:
            if template not in template_names:
                template_names.append(template)

        return self.combine_templates(template_names) 